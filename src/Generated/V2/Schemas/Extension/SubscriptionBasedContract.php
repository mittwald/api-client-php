<?php

declare(strict_types=1);

namespace Mittwald\ApiClient\Generated\V2\Schemas\Extension;

use DateTime;
use InvalidArgumentException;
use JsonSchema\Validator;

/**
 * A strategy for Contracts that will be paid periodically.
 *
 * DO NOT EDIT; this class was generated by the mittwald/api-client-builder package
 * (https://github.com/mittwald/api-client-php-builder). Please make any changes
 * there.
 *
 * @generated
 * @see https://github.com/mittwald/api-client-php-builder
 */
class SubscriptionBasedContract
{
    /**
     * Schema used to validate input for creating instances of this class
     */
    private static array $internalValidationSchema = [
        'description' => 'A strategy for Contracts that will be paid periodically.',
        'properties' => [
            'currentPrice' => [
                'description' => 'monthly price in Euro Cent',
                'example' => 999,
                'type' => 'integer',
            ],
            'interactionDeadline' => [
                'format' => 'date-time',
                'type' => 'string',
            ],
            'interactionRequired' => [
                'type' => 'boolean',
            ],
            'status' => [
                'enum' => [
                    'notStarted',
                    'pending',
                    'active',
                    'terminationPending',
                ],
                'type' => 'string',
            ],
            'terminationTargetDate' => [
                'format' => 'date-time',
                'type' => 'string',
            ],
            'variantDescription' => [
                'type' => 'string',
            ],
            'variantKey' => [
                'type' => 'string',
            ],
            'variantName' => [
                'type' => 'string',
            ],
        ],
        'required' => [
            'status',
            'interactionRequired',
        ],
        'type' => 'object',
    ];

    /**
     * monthly price in Euro Cent
     */
    private ?int $currentPrice = null;

    private ?DateTime $interactionDeadline = null;

    private bool $interactionRequired;

    private SubscriptionBasedContractStatus $status;

    private ?DateTime $terminationTargetDate = null;

    private ?string $variantDescription = null;

    private ?string $variantKey = null;

    private ?string $variantName = null;

    public function __construct(bool $interactionRequired, SubscriptionBasedContractStatus $status)
    {
        $this->interactionRequired = $interactionRequired;
        $this->status = $status;
    }

    public function getCurrentPrice(): ?int
    {
        return $this->currentPrice ?? null;
    }

    public function getInteractionDeadline(): ?DateTime
    {
        return $this->interactionDeadline ?? null;
    }

    public function getInteractionRequired(): bool
    {
        return $this->interactionRequired;
    }

    public function getStatus(): SubscriptionBasedContractStatus
    {
        return $this->status;
    }

    public function getTerminationTargetDate(): ?DateTime
    {
        return $this->terminationTargetDate ?? null;
    }

    public function getVariantDescription(): ?string
    {
        return $this->variantDescription ?? null;
    }

    public function getVariantKey(): ?string
    {
        return $this->variantKey ?? null;
    }

    public function getVariantName(): ?string
    {
        return $this->variantName ?? null;
    }

    public function withCurrentPrice(int $currentPrice): self
    {
        $validator = new Validator();
        $validator->validate($currentPrice, self::$internalValidationSchema['properties']['currentPrice']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->currentPrice = $currentPrice;

        return $clone;
    }

    public function withoutCurrentPrice(): self
    {
        $clone = clone $this;
        unset($clone->currentPrice);

        return $clone;
    }

    public function withInteractionDeadline(DateTime $interactionDeadline): self
    {
        $clone = clone $this;
        $clone->interactionDeadline = $interactionDeadline;

        return $clone;
    }

    public function withoutInteractionDeadline(): self
    {
        $clone = clone $this;
        unset($clone->interactionDeadline);

        return $clone;
    }

    public function withInteractionRequired(bool $interactionRequired): self
    {
        $validator = new Validator();
        $validator->validate($interactionRequired, self::$internalValidationSchema['properties']['interactionRequired']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->interactionRequired = $interactionRequired;

        return $clone;
    }

    public function withStatus(SubscriptionBasedContractStatus $status): self
    {
        $clone = clone $this;
        $clone->status = $status;

        return $clone;
    }

    public function withTerminationTargetDate(DateTime $terminationTargetDate): self
    {
        $clone = clone $this;
        $clone->terminationTargetDate = $terminationTargetDate;

        return $clone;
    }

    public function withoutTerminationTargetDate(): self
    {
        $clone = clone $this;
        unset($clone->terminationTargetDate);

        return $clone;
    }

    public function withVariantDescription(string $variantDescription): self
    {
        $validator = new Validator();
        $validator->validate($variantDescription, self::$internalValidationSchema['properties']['variantDescription']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->variantDescription = $variantDescription;

        return $clone;
    }

    public function withoutVariantDescription(): self
    {
        $clone = clone $this;
        unset($clone->variantDescription);

        return $clone;
    }

    public function withVariantKey(string $variantKey): self
    {
        $validator = new Validator();
        $validator->validate($variantKey, self::$internalValidationSchema['properties']['variantKey']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->variantKey = $variantKey;

        return $clone;
    }

    public function withoutVariantKey(): self
    {
        $clone = clone $this;
        unset($clone->variantKey);

        return $clone;
    }

    public function withVariantName(string $variantName): self
    {
        $validator = new Validator();
        $validator->validate($variantName, self::$internalValidationSchema['properties']['variantName']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->variantName = $variantName;

        return $clone;
    }

    public function withoutVariantName(): self
    {
        $clone = clone $this;
        unset($clone->variantName);

        return $clone;
    }

    /**
     * Builds a new instance from an input array
     *
     * @param array|object $input Input data
     * @param bool $validate Set this to false to skip validation; use at own risk
     * @return SubscriptionBasedContract Created instance
     * @throws InvalidArgumentException
     */
    public static function buildFromInput(array|object $input, bool $validate = true): SubscriptionBasedContract
    {
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        if ($validate) {
            static::validateInput($input);
        }

        $currentPrice = null;
        if (isset($input->{'currentPrice'})) {
            $currentPrice = (int)($input->{'currentPrice'});
        }
        $interactionDeadline = null;
        if (isset($input->{'interactionDeadline'})) {
            $interactionDeadline = new DateTime($input->{'interactionDeadline'});
        }
        $interactionRequired = (bool)($input->{'interactionRequired'});
        $status = SubscriptionBasedContractStatus::from($input->{'status'});
        $terminationTargetDate = null;
        if (isset($input->{'terminationTargetDate'})) {
            $terminationTargetDate = new DateTime($input->{'terminationTargetDate'});
        }
        $variantDescription = null;
        if (isset($input->{'variantDescription'})) {
            $variantDescription = $input->{'variantDescription'};
        }
        $variantKey = null;
        if (isset($input->{'variantKey'})) {
            $variantKey = $input->{'variantKey'};
        }
        $variantName = null;
        if (isset($input->{'variantName'})) {
            $variantName = $input->{'variantName'};
        }

        $obj = new self($interactionRequired, $status);
        $obj->currentPrice = $currentPrice;
        $obj->interactionDeadline = $interactionDeadline;
        $obj->terminationTargetDate = $terminationTargetDate;
        $obj->variantDescription = $variantDescription;
        $obj->variantKey = $variantKey;
        $obj->variantName = $variantName;
        return $obj;
    }

    /**
     * Converts this object back to a simple array that can be JSON-serialized
     *
     * @return array Converted array
     */
    public function toJson(): array
    {
        $output = [];
        if (isset($this->currentPrice)) {
            $output['currentPrice'] = $this->currentPrice;
        }
        if (isset($this->interactionDeadline)) {
            $output['interactionDeadline'] = ($this->interactionDeadline)->format(DateTime::ATOM);
        }
        $output['interactionRequired'] = $this->interactionRequired;
        $output['status'] = ($this->status)->value;
        if (isset($this->terminationTargetDate)) {
            $output['terminationTargetDate'] = ($this->terminationTargetDate)->format(DateTime::ATOM);
        }
        if (isset($this->variantDescription)) {
            $output['variantDescription'] = $this->variantDescription;
        }
        if (isset($this->variantKey)) {
            $output['variantKey'] = $this->variantKey;
        }
        if (isset($this->variantName)) {
            $output['variantName'] = $this->variantName;
        }

        return $output;
    }

    /**
     * Validates an input array
     *
     * @param array|object $input Input data
     * @param bool $return Return instead of throwing errors
     * @return bool Validation result
     * @throws InvalidArgumentException
     */
    public static function validateInput(array|object $input, bool $return = false): bool
    {
        $validator = new \Mittwald\ApiClient\Validator\Validator();
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        $validator->validate($input, self::$internalValidationSchema);

        if (!$validator->isValid() && !$return) {
            $errors = array_map(function (array $e): string {
                return $e["property"] . ": " . $e["message"];
            }, $validator->getErrors());
            throw new InvalidArgumentException(join(", ", $errors));
        }

        return $validator->isValid();
    }

    public function __clone()
    {
        if (isset($this->interactionDeadline)) {
            $this->interactionDeadline = clone $this->interactionDeadline;
        }
        if (isset($this->terminationTargetDate)) {
            $this->terminationTargetDate = clone $this->terminationTargetDate;
        }
    }
}
