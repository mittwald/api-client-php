<?php

declare(strict_types=1);

namespace Mittwald\ApiClient\Generated\V2\Schemas\Storagespace;

use DateTime;
use InvalidArgumentException;
use JsonSchema\Validator;

/**
 * Auto-generated class for de.mittwald.v1.storagespace.StatisticsMeta.
 *
 * DO NOT EDIT; this class was generated by the mittwald/api-client-builder package
 * (https://github.com/mittwald/api-client-php-builder). Please make any changes
 * there.
 *
 * @generated
 * @see https://github.com/mittwald/api-client-php-builder
 */
class StatisticsMeta
{
    /**
     * Schema used to validate input for creating instances of this class
     */
    private static array $internalValidationSchema = [
        'properties' => [
            'isExceeding' => [
                'example' => false,
                'type' => 'boolean',
            ],
            'lastExceedanceLimitInBytes' => [
                'description' => 'The last exceedance limit in bytes during the exceedance time, therefore can differ from the current limit. It is retained as a historical record of the most recent exceedance and does not reset once set.',
                'example' => 10,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'lastTotalExceedanceInBytes' => [
                'description' => 'The last total exceedance in bytes related to the limit during the exceedance time, see lastExceedanceLimitInBytes. It is retained as a historical record of the most recent exceedance and does not reset once set.',
                'example' => 10,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'lastTotalExceedanceInBytesSetAt' => [
                'description' => 'The last total exceedance date. It is retained as a historical record of the most recent exceedance and does not reset once set.',
                'example' => '2023-12-22T13:46:52.000Z',
                'format' => 'date-time',
                'type' => 'string',
            ],
            'limitInBytes' => [
                'example' => 100000,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'notificationThresholdUsedAsLimit' => [
                'description' => 'If true, set notification threshold is used as limit for meta calculations. E.g. for projects with a parent server.',
                'example' => false,
                'type' => 'boolean',
            ],
            'totalExceedanceInBytes' => [
                'description' => 'The current total exceedance in bytes.',
                'example' => 10,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'totalExceedanceInBytesSetAt' => [
                'description' => 'The current total exceedance date.',
                'example' => '2023-12-22T13:46:52.000Z',
                'format' => 'date-time',
                'type' => 'string',
            ],
            'totalFreeInBytes' => [
                'example' => 99000,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'totalFreeInPercentage' => [
                'example' => 90,
                'type' => 'number',
            ],
            'totalUsageInBytes' => [
                'example' => 1000,
                'format' => 'int64',
                'type' => 'integer',
            ],
            'totalUsageInPercentage' => [
                'example' => 10,
                'type' => 'number',
            ],
        ],
        'required' => [
            'totalUsageInBytes',
        ],
        'type' => 'object',
    ];

    private ?bool $isExceeding = null;

    /**
     * The last exceedance limit in bytes during the exceedance time, therefore can differ from the current limit. It is retained as a historical record of the most recent exceedance and does not reset once set.
     */
    private ?int $lastExceedanceLimitInBytes = null;

    /**
     * The last total exceedance in bytes related to the limit during the exceedance time, see lastExceedanceLimitInBytes. It is retained as a historical record of the most recent exceedance and does not reset once set.
     */
    private ?int $lastTotalExceedanceInBytes = null;

    /**
     * The last total exceedance date. It is retained as a historical record of the most recent exceedance and does not reset once set.
     */
    private ?DateTime $lastTotalExceedanceInBytesSetAt = null;

    private ?int $limitInBytes = null;

    /**
     * If true, set notification threshold is used as limit for meta calculations. E.g. for projects with a parent server.
     */
    private ?bool $notificationThresholdUsedAsLimit = null;

    /**
     * The current total exceedance in bytes.
     */
    private ?int $totalExceedanceInBytes = null;

    /**
     * The current total exceedance date.
     */
    private ?DateTime $totalExceedanceInBytesSetAt = null;

    private ?int $totalFreeInBytes = null;

    private int|float|null $totalFreeInPercentage = null;

    private int $totalUsageInBytes;

    private int|float|null $totalUsageInPercentage = null;

    public function __construct(int $totalUsageInBytes)
    {
        $this->totalUsageInBytes = $totalUsageInBytes;
    }

    public function getIsExceeding(): ?bool
    {
        return $this->isExceeding ?? null;
    }

    public function getLastExceedanceLimitInBytes(): ?int
    {
        return $this->lastExceedanceLimitInBytes ?? null;
    }

    public function getLastTotalExceedanceInBytes(): ?int
    {
        return $this->lastTotalExceedanceInBytes ?? null;
    }

    public function getLastTotalExceedanceInBytesSetAt(): ?DateTime
    {
        return $this->lastTotalExceedanceInBytesSetAt ?? null;
    }

    public function getLimitInBytes(): ?int
    {
        return $this->limitInBytes ?? null;
    }

    public function getNotificationThresholdUsedAsLimit(): ?bool
    {
        return $this->notificationThresholdUsedAsLimit ?? null;
    }

    public function getTotalExceedanceInBytes(): ?int
    {
        return $this->totalExceedanceInBytes ?? null;
    }

    public function getTotalExceedanceInBytesSetAt(): ?DateTime
    {
        return $this->totalExceedanceInBytesSetAt ?? null;
    }

    public function getTotalFreeInBytes(): ?int
    {
        return $this->totalFreeInBytes ?? null;
    }

    public function getTotalFreeInPercentage(): int|float|null
    {
        return $this->totalFreeInPercentage;
    }

    public function getTotalUsageInBytes(): int
    {
        return $this->totalUsageInBytes;
    }

    public function getTotalUsageInPercentage(): int|float|null
    {
        return $this->totalUsageInPercentage;
    }

    public function withIsExceeding(bool $isExceeding): self
    {
        $validator = new Validator();
        $validator->validate($isExceeding, self::$internalValidationSchema['properties']['isExceeding']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->isExceeding = $isExceeding;

        return $clone;
    }

    public function withoutIsExceeding(): self
    {
        $clone = clone $this;
        unset($clone->isExceeding);

        return $clone;
    }

    public function withLastExceedanceLimitInBytes(int $lastExceedanceLimitInBytes): self
    {
        $validator = new Validator();
        $validator->validate($lastExceedanceLimitInBytes, self::$internalValidationSchema['properties']['lastExceedanceLimitInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->lastExceedanceLimitInBytes = $lastExceedanceLimitInBytes;

        return $clone;
    }

    public function withoutLastExceedanceLimitInBytes(): self
    {
        $clone = clone $this;
        unset($clone->lastExceedanceLimitInBytes);

        return $clone;
    }

    public function withLastTotalExceedanceInBytes(int $lastTotalExceedanceInBytes): self
    {
        $validator = new Validator();
        $validator->validate($lastTotalExceedanceInBytes, self::$internalValidationSchema['properties']['lastTotalExceedanceInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->lastTotalExceedanceInBytes = $lastTotalExceedanceInBytes;

        return $clone;
    }

    public function withoutLastTotalExceedanceInBytes(): self
    {
        $clone = clone $this;
        unset($clone->lastTotalExceedanceInBytes);

        return $clone;
    }

    public function withLastTotalExceedanceInBytesSetAt(DateTime $lastTotalExceedanceInBytesSetAt): self
    {
        $clone = clone $this;
        $clone->lastTotalExceedanceInBytesSetAt = $lastTotalExceedanceInBytesSetAt;

        return $clone;
    }

    public function withoutLastTotalExceedanceInBytesSetAt(): self
    {
        $clone = clone $this;
        unset($clone->lastTotalExceedanceInBytesSetAt);

        return $clone;
    }

    public function withLimitInBytes(int $limitInBytes): self
    {
        $validator = new Validator();
        $validator->validate($limitInBytes, self::$internalValidationSchema['properties']['limitInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->limitInBytes = $limitInBytes;

        return $clone;
    }

    public function withoutLimitInBytes(): self
    {
        $clone = clone $this;
        unset($clone->limitInBytes);

        return $clone;
    }

    public function withNotificationThresholdUsedAsLimit(bool $notificationThresholdUsedAsLimit): self
    {
        $validator = new Validator();
        $validator->validate($notificationThresholdUsedAsLimit, self::$internalValidationSchema['properties']['notificationThresholdUsedAsLimit']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->notificationThresholdUsedAsLimit = $notificationThresholdUsedAsLimit;

        return $clone;
    }

    public function withoutNotificationThresholdUsedAsLimit(): self
    {
        $clone = clone $this;
        unset($clone->notificationThresholdUsedAsLimit);

        return $clone;
    }

    public function withTotalExceedanceInBytes(int $totalExceedanceInBytes): self
    {
        $validator = new Validator();
        $validator->validate($totalExceedanceInBytes, self::$internalValidationSchema['properties']['totalExceedanceInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->totalExceedanceInBytes = $totalExceedanceInBytes;

        return $clone;
    }

    public function withoutTotalExceedanceInBytes(): self
    {
        $clone = clone $this;
        unset($clone->totalExceedanceInBytes);

        return $clone;
    }

    public function withTotalExceedanceInBytesSetAt(DateTime $totalExceedanceInBytesSetAt): self
    {
        $clone = clone $this;
        $clone->totalExceedanceInBytesSetAt = $totalExceedanceInBytesSetAt;

        return $clone;
    }

    public function withoutTotalExceedanceInBytesSetAt(): self
    {
        $clone = clone $this;
        unset($clone->totalExceedanceInBytesSetAt);

        return $clone;
    }

    public function withTotalFreeInBytes(int $totalFreeInBytes): self
    {
        $validator = new Validator();
        $validator->validate($totalFreeInBytes, self::$internalValidationSchema['properties']['totalFreeInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->totalFreeInBytes = $totalFreeInBytes;

        return $clone;
    }

    public function withoutTotalFreeInBytes(): self
    {
        $clone = clone $this;
        unset($clone->totalFreeInBytes);

        return $clone;
    }

    public function withTotalFreeInPercentage(int|float $totalFreeInPercentage): self
    {
        $validator = new Validator();
        $validator->validate($totalFreeInPercentage, self::$internalValidationSchema['properties']['totalFreeInPercentage']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->totalFreeInPercentage = $totalFreeInPercentage;

        return $clone;
    }

    public function withoutTotalFreeInPercentage(): self
    {
        $clone = clone $this;
        unset($clone->totalFreeInPercentage);

        return $clone;
    }

    public function withTotalUsageInBytes(int $totalUsageInBytes): self
    {
        $validator = new Validator();
        $validator->validate($totalUsageInBytes, self::$internalValidationSchema['properties']['totalUsageInBytes']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->totalUsageInBytes = $totalUsageInBytes;

        return $clone;
    }

    public function withTotalUsageInPercentage(int|float $totalUsageInPercentage): self
    {
        $validator = new Validator();
        $validator->validate($totalUsageInPercentage, self::$internalValidationSchema['properties']['totalUsageInPercentage']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->totalUsageInPercentage = $totalUsageInPercentage;

        return $clone;
    }

    public function withoutTotalUsageInPercentage(): self
    {
        $clone = clone $this;
        unset($clone->totalUsageInPercentage);

        return $clone;
    }

    /**
     * Builds a new instance from an input array
     *
     * @param array|object $input Input data
     * @param bool $validate Set this to false to skip validation; use at own risk
     * @return StatisticsMeta Created instance
     * @throws InvalidArgumentException
     */
    public static function buildFromInput(array|object $input, bool $validate = true): StatisticsMeta
    {
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        if ($validate) {
            static::validateInput($input);
        }

        $isExceeding = null;
        if (isset($input->{'isExceeding'})) {
            $isExceeding = (bool)($input->{'isExceeding'});
        }
        $lastExceedanceLimitInBytes = null;
        if (isset($input->{'lastExceedanceLimitInBytes'})) {
            $lastExceedanceLimitInBytes = (int)($input->{'lastExceedanceLimitInBytes'});
        }
        $lastTotalExceedanceInBytes = null;
        if (isset($input->{'lastTotalExceedanceInBytes'})) {
            $lastTotalExceedanceInBytes = (int)($input->{'lastTotalExceedanceInBytes'});
        }
        $lastTotalExceedanceInBytesSetAt = null;
        if (isset($input->{'lastTotalExceedanceInBytesSetAt'})) {
            $lastTotalExceedanceInBytesSetAt = new DateTime($input->{'lastTotalExceedanceInBytesSetAt'});
        }
        $limitInBytes = null;
        if (isset($input->{'limitInBytes'})) {
            $limitInBytes = (int)($input->{'limitInBytes'});
        }
        $notificationThresholdUsedAsLimit = null;
        if (isset($input->{'notificationThresholdUsedAsLimit'})) {
            $notificationThresholdUsedAsLimit = (bool)($input->{'notificationThresholdUsedAsLimit'});
        }
        $totalExceedanceInBytes = null;
        if (isset($input->{'totalExceedanceInBytes'})) {
            $totalExceedanceInBytes = (int)($input->{'totalExceedanceInBytes'});
        }
        $totalExceedanceInBytesSetAt = null;
        if (isset($input->{'totalExceedanceInBytesSetAt'})) {
            $totalExceedanceInBytesSetAt = new DateTime($input->{'totalExceedanceInBytesSetAt'});
        }
        $totalFreeInBytes = null;
        if (isset($input->{'totalFreeInBytes'})) {
            $totalFreeInBytes = (int)($input->{'totalFreeInBytes'});
        }
        $totalFreeInPercentage = null;
        if (isset($input->{'totalFreeInPercentage'})) {
            $totalFreeInPercentage = str_contains((string)($input->{'totalFreeInPercentage'}), '.') ? (float)($input->{'totalFreeInPercentage'}) : (int)($input->{'totalFreeInPercentage'});
        }
        $totalUsageInBytes = (int)($input->{'totalUsageInBytes'});
        $totalUsageInPercentage = null;
        if (isset($input->{'totalUsageInPercentage'})) {
            $totalUsageInPercentage = str_contains((string)($input->{'totalUsageInPercentage'}), '.') ? (float)($input->{'totalUsageInPercentage'}) : (int)($input->{'totalUsageInPercentage'});
        }

        $obj = new self($totalUsageInBytes);
        $obj->isExceeding = $isExceeding;
        $obj->lastExceedanceLimitInBytes = $lastExceedanceLimitInBytes;
        $obj->lastTotalExceedanceInBytes = $lastTotalExceedanceInBytes;
        $obj->lastTotalExceedanceInBytesSetAt = $lastTotalExceedanceInBytesSetAt;
        $obj->limitInBytes = $limitInBytes;
        $obj->notificationThresholdUsedAsLimit = $notificationThresholdUsedAsLimit;
        $obj->totalExceedanceInBytes = $totalExceedanceInBytes;
        $obj->totalExceedanceInBytesSetAt = $totalExceedanceInBytesSetAt;
        $obj->totalFreeInBytes = $totalFreeInBytes;
        $obj->totalFreeInPercentage = $totalFreeInPercentage;
        $obj->totalUsageInPercentage = $totalUsageInPercentage;
        return $obj;
    }

    /**
     * Converts this object back to a simple array that can be JSON-serialized
     *
     * @return array Converted array
     */
    public function toJson(): array
    {
        $output = [];
        if (isset($this->isExceeding)) {
            $output['isExceeding'] = $this->isExceeding;
        }
        if (isset($this->lastExceedanceLimitInBytes)) {
            $output['lastExceedanceLimitInBytes'] = $this->lastExceedanceLimitInBytes;
        }
        if (isset($this->lastTotalExceedanceInBytes)) {
            $output['lastTotalExceedanceInBytes'] = $this->lastTotalExceedanceInBytes;
        }
        if (isset($this->lastTotalExceedanceInBytesSetAt)) {
            $output['lastTotalExceedanceInBytesSetAt'] = ($this->lastTotalExceedanceInBytesSetAt)->format(DateTime::ATOM);
        }
        if (isset($this->limitInBytes)) {
            $output['limitInBytes'] = $this->limitInBytes;
        }
        if (isset($this->notificationThresholdUsedAsLimit)) {
            $output['notificationThresholdUsedAsLimit'] = $this->notificationThresholdUsedAsLimit;
        }
        if (isset($this->totalExceedanceInBytes)) {
            $output['totalExceedanceInBytes'] = $this->totalExceedanceInBytes;
        }
        if (isset($this->totalExceedanceInBytesSetAt)) {
            $output['totalExceedanceInBytesSetAt'] = ($this->totalExceedanceInBytesSetAt)->format(DateTime::ATOM);
        }
        if (isset($this->totalFreeInBytes)) {
            $output['totalFreeInBytes'] = $this->totalFreeInBytes;
        }
        if (isset($this->totalFreeInPercentage)) {
            $output['totalFreeInPercentage'] = $this->totalFreeInPercentage;
        }
        $output['totalUsageInBytes'] = $this->totalUsageInBytes;
        if (isset($this->totalUsageInPercentage)) {
            $output['totalUsageInPercentage'] = $this->totalUsageInPercentage;
        }

        return $output;
    }

    /**
     * Validates an input array
     *
     * @param array|object $input Input data
     * @param bool $return Return instead of throwing errors
     * @return bool Validation result
     * @throws InvalidArgumentException
     */
    public static function validateInput(array|object $input, bool $return = false): bool
    {
        $validator = new \Mittwald\ApiClient\Validator\Validator();
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        $validator->validate($input, self::$internalValidationSchema);

        if (!$validator->isValid() && !$return) {
            $errors = array_map(function (array $e): string {
                return $e["property"] . ": " . $e["message"];
            }, $validator->getErrors());
            throw new InvalidArgumentException(join(", ", $errors));
        }

        return $validator->isValid();
    }

    public function __clone()
    {
        if (isset($this->lastTotalExceedanceInBytesSetAt)) {
            $this->lastTotalExceedanceInBytesSetAt = clone $this->lastTotalExceedanceInBytesSetAt;
        }
        if (isset($this->totalExceedanceInBytesSetAt)) {
            $this->totalExceedanceInBytesSetAt = clone $this->totalExceedanceInBytesSetAt;
        }
    }
}
