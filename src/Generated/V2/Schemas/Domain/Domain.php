<?php

declare(strict_types=1);

namespace Mittwald\ApiClient\Generated\V2\Schemas\Domain;

use InvalidArgumentException;
use JsonSchema\Validator;

/**
 * Auto-generated class for de.mittwald.v1.domain.Domain.
 *
 * DO NOT EDIT; this class was generated by the mittwald/api-client-builder package
 * (https://github.com/mittwald/api-client-php-builder). Please make any changes
 * there.
 *
 * @generated
 * @see https://github.com/mittwald/api-client-php-builder
 */
class Domain
{
    /**
     * Schema used to validate input for creating instances of this class
     */
    private static array $schema = [
        'properties' => [
            'authCode' => [
                '$ref' => '#/components/schemas/de.mittwald.v1.domain.AuthCode',
            ],
            'authCode2' => [
                '$ref' => '#/components/schemas/de.mittwald.v1.domain.AuthCode2',
            ],
            'connected' => [
                'type' => 'boolean',
            ],
            'contactHash' => [
                'type' => 'string',
            ],
            'deleted' => [
                'type' => 'boolean',
            ],
            'domain' => [
                'format' => 'naked-domain',
                'type' => 'string',
            ],
            'domainId' => [
                'format' => 'uuid',
                'type' => 'string',
            ],
            'handles' => [
                'properties' => [
                    'adminC' => [
                        '$ref' => '#/components/schemas/de.mittwald.v1.domain.HandleReadable',
                    ],
                    'ownerC' => [
                        '$ref' => '#/components/schemas/de.mittwald.v1.domain.HandleReadable',
                    ],
                ],
                'required' => [
                    'ownerC',
                ],
                'type' => 'object',
            ],
            'nameservers' => [
                'items' => [
                    'format' => 'idn-hostname',
                    'type' => 'string',
                ],
                'type' => 'array',
                'uniqueItems' => true,
            ],
            'processes' => [
                'items' => [
                    '$ref' => '#/components/schemas/de.mittwald.v1.domain.Process',
                ],
                'type' => 'array',
            ],
            'projectId' => [
                'format' => 'uuid',
                'type' => 'string',
            ],
            'transferInAuthCode' => [
                'type' => 'string',
            ],
            'usesDefaultNameserver' => [
                'type' => 'boolean',
            ],
        ],
        'required' => [
            'domainId',
            'domain',
            'projectId',
            'deleted',
            'nameservers',
            'handles',
            'connected',
            'usesDefaultNameserver',
            'hasAuthCode',
        ],
        'type' => 'object',
    ];

    private ?AuthCode $authCode = null;

    private ?AuthCode2 $authCode2 = null;

    private bool $connected;

    private ?string $contactHash = null;

    private bool $deleted;

    private string $domain;

    private string $domainId;

    private DomainHandles $handles;

    /**
     * @var string[]
     */
    private array $nameservers;

    /**
     * @var Process[]|null
     */
    private ?array $processes = null;

    private string $projectId;

    private ?string $transferInAuthCode = null;

    private bool $usesDefaultNameserver;

    /**
     * @param string[] $nameservers
     */
    public function __construct(bool $connected, bool $deleted, string $domain, string $domainId, DomainHandles $handles, array $nameservers, string $projectId, bool $usesDefaultNameserver)
    {
        $this->connected = $connected;
        $this->deleted = $deleted;
        $this->domain = $domain;
        $this->domainId = $domainId;
        $this->handles = $handles;
        $this->nameservers = $nameservers;
        $this->projectId = $projectId;
        $this->usesDefaultNameserver = $usesDefaultNameserver;
    }

    public function getAuthCode(): ?AuthCode
    {
        return $this->authCode ?? null;
    }

    public function getAuthCode2(): ?AuthCode2
    {
        return $this->authCode2 ?? null;
    }

    public function getConnected(): bool
    {
        return $this->connected;
    }

    public function getContactHash(): ?string
    {
        return $this->contactHash ?? null;
    }

    public function getDeleted(): bool
    {
        return $this->deleted;
    }

    public function getDomain(): string
    {
        return $this->domain;
    }

    public function getDomainId(): string
    {
        return $this->domainId;
    }

    public function getHandles(): DomainHandles
    {
        return $this->handles;
    }

    /**
     * @return string[]
     */
    public function getNameservers(): array
    {
        return $this->nameservers;
    }

    /**
     * @return Process[]|null
     */
    public function getProcesses(): ?array
    {
        return $this->processes ?? null;
    }

    public function getProjectId(): string
    {
        return $this->projectId;
    }

    public function getTransferInAuthCode(): ?string
    {
        return $this->transferInAuthCode ?? null;
    }

    public function getUsesDefaultNameserver(): bool
    {
        return $this->usesDefaultNameserver;
    }

    public function withAuthCode(AuthCode $authCode): self
    {
        $clone = clone $this;
        $clone->authCode = $authCode;

        return $clone;
    }

    public function withoutAuthCode(): self
    {
        $clone = clone $this;
        unset($clone->authCode);

        return $clone;
    }

    public function withAuthCode2(AuthCode2 $authCode2): self
    {
        $clone = clone $this;
        $clone->authCode2 = $authCode2;

        return $clone;
    }

    public function withoutAuthCode2(): self
    {
        $clone = clone $this;
        unset($clone->authCode2);

        return $clone;
    }

    public function withConnected(bool $connected): self
    {
        $validator = new Validator();
        $validator->validate($connected, static::$schema['properties']['connected']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->connected = $connected;

        return $clone;
    }

    public function withContactHash(string $contactHash): self
    {
        $validator = new Validator();
        $validator->validate($contactHash, static::$schema['properties']['contactHash']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->contactHash = $contactHash;

        return $clone;
    }

    public function withoutContactHash(): self
    {
        $clone = clone $this;
        unset($clone->contactHash);

        return $clone;
    }

    public function withDeleted(bool $deleted): self
    {
        $validator = new Validator();
        $validator->validate($deleted, static::$schema['properties']['deleted']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->deleted = $deleted;

        return $clone;
    }

    public function withDomain(string $domain): self
    {
        $validator = new Validator();
        $validator->validate($domain, static::$schema['properties']['domain']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->domain = $domain;

        return $clone;
    }

    public function withDomainId(string $domainId): self
    {
        $validator = new Validator();
        $validator->validate($domainId, static::$schema['properties']['domainId']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->domainId = $domainId;

        return $clone;
    }

    public function withHandles(DomainHandles $handles): self
    {
        $clone = clone $this;
        $clone->handles = $handles;

        return $clone;
    }

    /**
     * @param string[] $nameservers
     */
    public function withNameservers(array $nameservers): self
    {
        $validator = new Validator();
        $validator->validate($nameservers, static::$schema['properties']['nameservers']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->nameservers = $nameservers;

        return $clone;
    }

    /**
     * @param Process[] $processes
     */
    public function withProcesses(array $processes): self
    {
        $clone = clone $this;
        $clone->processes = $processes;

        return $clone;
    }

    public function withoutProcesses(): self
    {
        $clone = clone $this;
        unset($clone->processes);

        return $clone;
    }

    public function withProjectId(string $projectId): self
    {
        $validator = new Validator();
        $validator->validate($projectId, static::$schema['properties']['projectId']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->projectId = $projectId;

        return $clone;
    }

    public function withTransferInAuthCode(string $transferInAuthCode): self
    {
        $validator = new Validator();
        $validator->validate($transferInAuthCode, static::$schema['properties']['transferInAuthCode']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->transferInAuthCode = $transferInAuthCode;

        return $clone;
    }

    public function withoutTransferInAuthCode(): self
    {
        $clone = clone $this;
        unset($clone->transferInAuthCode);

        return $clone;
    }

    public function withUsesDefaultNameserver(bool $usesDefaultNameserver): self
    {
        $validator = new Validator();
        $validator->validate($usesDefaultNameserver, static::$schema['properties']['usesDefaultNameserver']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->usesDefaultNameserver = $usesDefaultNameserver;

        return $clone;
    }

    /**
     * Builds a new instance from an input array
     *
     * @param array|object $input Input data
     * @param bool $validate Set this to false to skip validation; use at own risk
     * @return Domain Created instance
     * @throws InvalidArgumentException
     */
    public static function buildFromInput(array|object $input, bool $validate = true): Domain
    {
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        if ($validate) {
            static::validateInput($input);
        }

        $authCode = null;
        if (isset($input->{'authCode'})) {
            $authCode = AuthCode::buildFromInput($input->{'authCode'}, validate: $validate);
        }
        $authCode2 = null;
        if (isset($input->{'authCode2'})) {
            $authCode2 = AuthCode2::buildFromInput($input->{'authCode2'}, validate: $validate);
        }
        $connected = (bool)($input->{'connected'});
        $contactHash = null;
        if (isset($input->{'contactHash'})) {
            $contactHash = $input->{'contactHash'};
        }
        $deleted = (bool)($input->{'deleted'});
        $domain = $input->{'domain'};
        $domainId = $input->{'domainId'};
        $handles = DomainHandles::buildFromInput($input->{'handles'}, validate: $validate);
        $nameservers = $input->{'nameservers'};
        $processes = null;
        if (isset($input->{'processes'})) {
            $processes = array_map(fn (array|object $i): Process => Process::buildFromInput($i, validate: $validate), $input->{'processes'});
        }
        $projectId = $input->{'projectId'};
        $transferInAuthCode = null;
        if (isset($input->{'transferInAuthCode'})) {
            $transferInAuthCode = $input->{'transferInAuthCode'};
        }
        $usesDefaultNameserver = (bool)($input->{'usesDefaultNameserver'});

        $obj = new self($connected, $deleted, $domain, $domainId, $handles, $nameservers, $projectId, $usesDefaultNameserver);
        $obj->authCode = $authCode;
        $obj->authCode2 = $authCode2;
        $obj->contactHash = $contactHash;
        $obj->processes = $processes;
        $obj->transferInAuthCode = $transferInAuthCode;
        return $obj;
    }

    /**
     * Converts this object back to a simple array that can be JSON-serialized
     *
     * @return array Converted array
     */
    public function toJson(): array
    {
        $output = [];
        if (isset($this->authCode)) {
            $output['authCode'] = $this->authCode->toJson();
        }
        if (isset($this->authCode2)) {
            $output['authCode2'] = $this->authCode2->toJson();
        }
        $output['connected'] = $this->connected;
        if (isset($this->contactHash)) {
            $output['contactHash'] = $this->contactHash;
        }
        $output['deleted'] = $this->deleted;
        $output['domain'] = $this->domain;
        $output['domainId'] = $this->domainId;
        $output['handles'] = ($this->handles)->toJson();
        $output['nameservers'] = $this->nameservers;
        if (isset($this->processes)) {
            $output['processes'] = array_map(fn (Process $i): array => $i->toJson(), $this->processes);
        }
        $output['projectId'] = $this->projectId;
        if (isset($this->transferInAuthCode)) {
            $output['transferInAuthCode'] = $this->transferInAuthCode;
        }
        $output['usesDefaultNameserver'] = $this->usesDefaultNameserver;

        return $output;
    }

    /**
     * Validates an input array
     *
     * @param array|object $input Input data
     * @param bool $return Return instead of throwing errors
     * @return bool Validation result
     * @throws InvalidArgumentException
     */
    public static function validateInput(array|object $input, bool $return = false): bool
    {
        $validator = new \Mittwald\ApiClient\Validator\Validator();
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        $validator->validate($input, static::$schema);

        if (!$validator->isValid() && !$return) {
            $errors = array_map(function (array $e): string {
                return $e["property"] . ": " . $e["message"];
            }, $validator->getErrors());
            throw new InvalidArgumentException(join(", ", $errors));
        }

        return $validator->isValid();
    }

    public function __clone()
    {
        $this->handles = clone $this->handles;
    }
}
