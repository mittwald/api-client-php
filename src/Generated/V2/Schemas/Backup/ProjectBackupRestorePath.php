<?php

declare(strict_types=1);

namespace Mittwald\ApiClient\Generated\V2\Schemas\Backup;

use InvalidArgumentException;
use JsonSchema\Validator;

/**
 * Auto-generated class for de.mittwald.v1.backup.ProjectBackupRestorePath.
 *
 * DO NOT EDIT; this class was generated by the mittwald/api-client-builder package
 * (https://github.com/mittwald/api-client-php-builder). Please make any changes
 * there.
 *
 * @generated
 * @see https://github.com/mittwald/api-client-php-builder
 */
class ProjectBackupRestorePath
{
    /**
     * Schema used to validate input for creating instances of this class
     */
    private static array $internalValidationSchema = [
        'properties' => [
            'clearTargetPath' => [
                'default' => false,
                'description' => 'Whether to clear the target path before restoring. If true, existing files in the target path will be deleted before the restore. If false, existing files will be kept and may be overwritten if they exist in the backup.',
                'type' => 'boolean',
            ],
            'sourcePath' => [
                'description' => 'Source path within the backup to restore from. If not set, it will be determined as \'/data-p-shortId-userdata/p-shortId/web\' as it\'s originally sourced from there.',
                'example' => '/data-p-shortId-userdata/p-shortId/web',
                'type' => 'string',
            ],
            'targetPath' => [
                'description' => 'Target path where the backup should be restored to. If not set, equaled source path with adjusted path mapping. The target path will be determined to equal the origin source, e.g. \'/data-p-shortid-userdata/p-shortid/web\' will be determined as \'data-p-shortid-userdata/p-shortid/web\' as it\'s originally sourced from there.',
                'example' => 'data-p-shortId-userdata/p-shortId/web',
                'type' => 'string',
            ],
        ],
        'type' => 'object',
    ];

    /**
     * Whether to clear the target path before restoring. If true, existing files in the target path will be deleted before the restore. If false, existing files will be kept and may be overwritten if they exist in the backup.
     */
    private bool $clearTargetPath = false;

    /**
     * Source path within the backup to restore from. If not set, it will be determined as '/data-p-shortId-userdata/p-shortId/web' as it's originally sourced from there.
     */
    private ?string $sourcePath = null;

    /**
     * Target path where the backup should be restored to. If not set, equaled source path with adjusted path mapping. The target path will be determined to equal the origin source, e.g. '/data-p-shortid-userdata/p-shortid/web' will be determined as 'data-p-shortid-userdata/p-shortid/web' as it's originally sourced from there.
     */
    private ?string $targetPath = null;

    /**
     *
     */
    public function __construct()
    {
    }

    public function getClearTargetPath(): bool
    {
        return $this->clearTargetPath;
    }

    public function getSourcePath(): ?string
    {
        return $this->sourcePath ?? null;
    }

    public function getTargetPath(): ?string
    {
        return $this->targetPath ?? null;
    }

    public function withClearTargetPath(bool $clearTargetPath): self
    {
        $validator = new Validator();
        $validator->validate($clearTargetPath, self::$internalValidationSchema['properties']['clearTargetPath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->clearTargetPath = $clearTargetPath;

        return $clone;
    }

    public function withSourcePath(string $sourcePath): self
    {
        $validator = new Validator();
        $validator->validate($sourcePath, self::$internalValidationSchema['properties']['sourcePath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->sourcePath = $sourcePath;

        return $clone;
    }

    public function withoutSourcePath(): self
    {
        $clone = clone $this;
        unset($clone->sourcePath);

        return $clone;
    }

    public function withTargetPath(string $targetPath): self
    {
        $validator = new Validator();
        $validator->validate($targetPath, self::$internalValidationSchema['properties']['targetPath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->targetPath = $targetPath;

        return $clone;
    }

    public function withoutTargetPath(): self
    {
        $clone = clone $this;
        unset($clone->targetPath);

        return $clone;
    }

    /**
     * Builds a new instance from an input array
     *
     * @param array|object $input Input data
     * @param bool $validate Set this to false to skip validation; use at own risk
     * @return ProjectBackupRestorePath Created instance
     * @throws InvalidArgumentException
     */
    public static function buildFromInput(array|object $input, bool $validate = true): ProjectBackupRestorePath
    {
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        if ($validate) {
            static::validateInput($input);
        }

        $clearTargetPath = false;
        if (isset($input->{'clearTargetPath'})) {
            $clearTargetPath = (bool)($input->{'clearTargetPath'});
        }
        $sourcePath = null;
        if (isset($input->{'sourcePath'})) {
            $sourcePath = $input->{'sourcePath'};
        }
        $targetPath = null;
        if (isset($input->{'targetPath'})) {
            $targetPath = $input->{'targetPath'};
        }

        $obj = new self();
        $obj->clearTargetPath = $clearTargetPath;
        $obj->sourcePath = $sourcePath;
        $obj->targetPath = $targetPath;
        return $obj;
    }

    /**
     * Converts this object back to a simple array that can be JSON-serialized
     *
     * @return array Converted array
     */
    public function toJson(): array
    {
        $output = [];
        $output['clearTargetPath'] = $this->clearTargetPath;
        if (isset($this->sourcePath)) {
            $output['sourcePath'] = $this->sourcePath;
        }
        if (isset($this->targetPath)) {
            $output['targetPath'] = $this->targetPath;
        }

        return $output;
    }

    /**
     * Validates an input array
     *
     * @param array|object $input Input data
     * @param bool $return Return instead of throwing errors
     * @return bool Validation result
     * @throws InvalidArgumentException
     */
    public static function validateInput(array|object $input, bool $return = false): bool
    {
        $validator = new \Mittwald\ApiClient\Validator\Validator();
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        $validator->validate($input, self::$internalValidationSchema);

        if (!$validator->isValid() && !$return) {
            $errors = array_map(function (array $e): string {
                return $e["property"] . ": " . $e["message"];
            }, $validator->getErrors());
            throw new InvalidArgumentException(join(", ", $errors));
        }

        return $validator->isValid();
    }

    public function __clone()
    {
    }
}
