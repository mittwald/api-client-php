<?php

declare(strict_types=1);

namespace Mittwald\ApiClient\Generated\V2\Schemas\Backup;

use InvalidArgumentException;
use JsonSchema\Validator;

/**
 * Auto-generated class for de.mittwald.v1.backup.ProjectBackupRestorePathRequest.
 *
 * DO NOT EDIT; this class was generated by the mittwald/api-client-builder package
 * (https://github.com/mittwald/api-client-php-builder). Please make any changes
 * there.
 *
 * @generated
 * @see https://github.com/mittwald/api-client-php-builder
 */
class ProjectBackupRestorePathRequest
{
    /**
     * Schema used to validate input for creating instances of this class
     */
    private static array $internalValidationSchema = [
        'properties' => [
            'clearTargetPath' => [
                'default' => false,
                'description' => 'Whether to clear the target path before restoring. If true, existing files in the target path will be deleted before the restore. If false, existing files will be kept and may be overwritten if they exist in the backup.',
                'type' => 'boolean',
            ],
            'sourcePath' => [
                'example' => '/html/mainApp/config/',
                'type' => 'string',
            ],
            'targetPath' => [
                'description' => 'Target path where the source path should be restored to. If not set, the target path will be determined to equal the origin source. The target path should always be a folder, no files allowed here.',
                'example' => '/html/mainApp',
                'type' => 'string',
            ],
        ],
        'required' => [
            'sourcePath',
        ],
        'type' => 'object',
    ];

    /**
     * Whether to clear the target path before restoring. If true, existing files in the target path will be deleted before the restore. If false, existing files will be kept and may be overwritten if they exist in the backup.
     */
    private bool $clearTargetPath = false;

    private string $sourcePath;

    /**
     * Target path where the source path should be restored to. If not set, the target path will be determined to equal the origin source. The target path should always be a folder, no files allowed here.
     */
    private ?string $targetPath = null;

    public function __construct(string $sourcePath)
    {
        $this->sourcePath = $sourcePath;
    }

    public function getClearTargetPath(): bool
    {
        return $this->clearTargetPath;
    }

    public function getSourcePath(): string
    {
        return $this->sourcePath;
    }

    public function getTargetPath(): ?string
    {
        return $this->targetPath ?? null;
    }

    public function withClearTargetPath(bool $clearTargetPath): self
    {
        $validator = new Validator();
        $validator->validate($clearTargetPath, self::$internalValidationSchema['properties']['clearTargetPath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->clearTargetPath = $clearTargetPath;

        return $clone;
    }

    public function withSourcePath(string $sourcePath): self
    {
        $validator = new Validator();
        $validator->validate($sourcePath, self::$internalValidationSchema['properties']['sourcePath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->sourcePath = $sourcePath;

        return $clone;
    }

    public function withTargetPath(string $targetPath): self
    {
        $validator = new Validator();
        $validator->validate($targetPath, self::$internalValidationSchema['properties']['targetPath']);
        if (!$validator->isValid()) {
            throw new InvalidArgumentException($validator->getErrors()[0]['message']);
        }

        $clone = clone $this;
        $clone->targetPath = $targetPath;

        return $clone;
    }

    public function withoutTargetPath(): self
    {
        $clone = clone $this;
        unset($clone->targetPath);

        return $clone;
    }

    /**
     * Builds a new instance from an input array
     *
     * @param array|object $input Input data
     * @param bool $validate Set this to false to skip validation; use at own risk
     * @return ProjectBackupRestorePathRequest Created instance
     * @throws InvalidArgumentException
     */
    public static function buildFromInput(array|object $input, bool $validate = true): ProjectBackupRestorePathRequest
    {
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        if ($validate) {
            static::validateInput($input);
        }

        $clearTargetPath = false;
        if (isset($input->{'clearTargetPath'})) {
            $clearTargetPath = (bool)($input->{'clearTargetPath'});
        }
        $sourcePath = $input->{'sourcePath'};
        $targetPath = null;
        if (isset($input->{'targetPath'})) {
            $targetPath = $input->{'targetPath'};
        }

        $obj = new self($sourcePath);
        $obj->clearTargetPath = $clearTargetPath;
        $obj->targetPath = $targetPath;
        return $obj;
    }

    /**
     * Converts this object back to a simple array that can be JSON-serialized
     *
     * @return array Converted array
     */
    public function toJson(): array
    {
        $output = [];
        $output['clearTargetPath'] = $this->clearTargetPath;
        $output['sourcePath'] = $this->sourcePath;
        if (isset($this->targetPath)) {
            $output['targetPath'] = $this->targetPath;
        }

        return $output;
    }

    /**
     * Validates an input array
     *
     * @param array|object $input Input data
     * @param bool $return Return instead of throwing errors
     * @return bool Validation result
     * @throws InvalidArgumentException
     */
    public static function validateInput(array|object $input, bool $return = false): bool
    {
        $validator = new \Mittwald\ApiClient\Validator\Validator();
        $input = is_array($input) ? Validator::arrayToObjectRecursive($input) : $input;
        $validator->validate($input, self::$internalValidationSchema);

        if (!$validator->isValid() && !$return) {
            $errors = array_map(function (array $e): string {
                return $e["property"] . ": " . $e["message"];
            }, $validator->getErrors());
            throw new InvalidArgumentException(join(", ", $errors));
        }

        return $validator->isValid();
    }

    public function __clone()
    {
    }
}
